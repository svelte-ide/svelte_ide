import { LocalStoragePersister, MemoryPersister, PersisterInterface } from '@/core/PersisterInterface.js'
import { indexedDBService } from '@/core/persistence/IndexedDBService.svelte.js'
import { crossTabSyncService } from '@/core/CrossTabSyncService.svelte.js'

const ENV_FALLBACK = (import.meta.env.VITE_INDEXEDDB_FALLBACK_STRATEGY || 'block').toLowerCase().replace(' ', '')
const ALLOWED_STRATEGIES = ['block', 'localstorage', 'memory', 'user-choice']

function sanitizeStoreName(namespace) {
  return `persister_${namespace.replace(/[^a-z0-9_-]/gi, '_')}`
}

function normalizeStrategy(strategy) {
  if (!strategy || typeof strategy !== 'string') {
    return 'block'
  }
  const normalized = strategy.toLowerCase().replace(' ', '')
  return ALLOWED_STRATEGIES.includes(normalized) ? normalized : 'block'
}

let ideStorePromise = null
async function getIdeStoreInstance() {
  if (!ideStorePromise) {
    ideStorePromise = import('@/stores/ideStore.svelte.js')
      .then(module => module.ideStore)
      .catch(() => null)
  }
  return ideStorePromise
}

async function notifyFallback(type, title, message) {
  const ideStore = await getIdeStoreInstance()
  if (ideStore?.addNotification) {
    ideStore.addNotification(title, message, type, 'IndexedDB')
  }
}

let modalModulePromise = null
async function promptFallbackChoice(namespace) {
  if (!modalModulePromise) {
    modalModulePromise = import('@/core/ModalService.svelte.js').catch(() => null)
  }
  const modalModule = await modalModulePromise
  if (!modalModule?.modalService) {
    console.warn('IndexedDBPersister: modal service unavailable, falling back to block strategy')
    return 'block'
  }
  const { modalService, MODAL_CANCELLED_BY_X } = modalModule
  const result = await modalService.confirm({
    icon: 'ðŸ—„ï¸',
    question: 'IndexedDB indisponible',
    description: `Impossible d'initialiser IndexedDB pour "${namespace}". Choisissez un mode dÃ©gradÃ©.`,
    buttons: [
      { id: 'localStorage', label: 'Stockage limitÃ© (localStorage)', payload: 'localstorage' },
      { id: 'memory', label: 'Pas de persistance (mÃ©moire)', payload: 'memory' },
      { id: 'cancel', label: 'Annuler', payload: 'cancel' }
    ]
  })
  const choice = result?.payload ?? result
  if (!choice || choice === MODAL_CANCELLED_BY_X || choice === 'cancel') {
    throw new Error('User cancelled due to IndexedDB unavailability')
  }
  return normalizeStrategy(choice)
}

async function createFallbackPersister(namespace, strategy, reason = 'IndexedDB unavailable') {
  const normalized = normalizeStrategy(strategy)
  switch (normalized) {
    case 'block':
      await notifyFallback('error', 'IndexedDB requis', `${reason}. Navigateur non supportÃ©.`)
      throw new Error(`IndexedDB is required but not available for namespace "${namespace}"`)
    case 'localstorage':
      await notifyFallback(
        'warning',
        'Mode dÃ©gradÃ© (localStorage)',
        'IndexedDB indisponible, activation dâ€™un stockage limitÃ© non chiffrÃ©.'
      )
      return new LocalStoragePersister(namespace)
    case 'memory':
      await notifyFallback(
        'warning',
        'Mode mÃ©moire temporaire',
        'IndexedDB indisponible, donnÃ©es perdues au rechargement.'
      )
      return new MemoryPersister(namespace)
    case 'user-choice': {
      const userStrategy = await promptFallbackChoice(namespace)
      return createFallbackPersister(namespace, userStrategy, reason)
    }
    default:
      throw new Error(`Unknown fallback strategy: ${strategy}`)
  }
}

export class IndexedDBPersister extends PersisterInterface {
  constructor(namespace, options = {}) {
    super(namespace)
    this.storeName = options.storeName || sanitizeStoreName(namespace)
    const globalStrategy = typeof indexedDBService.getFallbackStrategy === 'function'
      ? indexedDBService.getFallbackStrategy()
      : ENV_FALLBACK
    this.fallbackStrategy = normalizeStrategy(options.fallbackStrategy || globalStrategy)
    this.fallbackPersister = options.fallbackPersister || null
    this.fallbackPromise = null
    this.initialized = false
    this.initializingPromise = null
    this._forceFallback = false
    this._reason = 'IndexedDB unavailable'
    this.migratedLegacyKeys = new Set()

    if (typeof indexedDB === 'undefined' && !this.fallbackPersister) {
      this._forceFallback = true
      this._reason = 'IndexedDB API non disponible dans ce navigateur'
    }
  }

  async _ensureFallbackReady(reason = null) {
    if (this.fallbackPersister) {
      return this.fallbackPersister
    }
    if (!this.fallbackPromise) {
      this.fallbackPromise = createFallbackPersister(this.namespace, this.fallbackStrategy, reason || this._reason)
        .then(persister => {
          this.fallbackPersister = persister
          return persister
        })
    }
    return this.fallbackPromise
  }

  async _ensureReady() {
    if (this._forceFallback) {
      await this._ensureFallbackReady()
      return false
    }

    if (this.initialized) {
      return true
    }

    if (!this.initializingPromise) {
      this.initializingPromise = (async () => {
        if (typeof indexedDB === 'undefined') {
          this._forceFallback = true
          await this._ensureFallbackReady('IndexedDB indisponible dans cet environnement')
          return false
        }
        try {
          await indexedDBService.initialize()
          if (!indexedDBService.hasStore(this.storeName)) {
            await indexedDBService.ensureStore(this.storeName)
          }
          this.initialized = true
          return true
        } catch (error) {
          console.error(`IndexedDBPersister: Failed to initialize store "${this.storeName}"`, error)
          this._forceFallback = true
          await this._ensureFallbackReady(`Impossible d'initialiser IndexedDB (${error.message})`)
          return false
        }
      })()
    }

    return this.initializingPromise
  }

  async _runFallback(method, ...args) {
    const persister = await this._ensureFallbackReady()
    if (!persister || typeof persister[method] !== 'function') {
      return false
    }
    const result = persister[method](...args)
    return result instanceof Promise ? await result : result
  }

  async save(key, data) {
    if (!key) {
      console.warn('IndexedDBPersister: save() called without a key')
      return false
    }

    try {
      const canUseIndexedDB = await this._ensureReady()
      if (this._forceFallback || !canUseIndexedDB) {
        const fallbackResult = await this._runFallback('save', key, data)
        if (fallbackResult) {
          this._broadcastChange('save', key)
        }
        return fallbackResult
      }
      const fullKey = this.getFullKey(key)
      const success = await indexedDBService.save(this.storeName, fullKey, data)
      if (success) {
        this._broadcastChange('save', key)
      }
      return Boolean(success)
    } catch (error) {
      console.error(`IndexedDBPersister: Failed to save key "${key}"`, error)
      if (this._forceFallback) {
        const fallbackResult = await this._runFallback('save', key, data)
        if (fallbackResult) {
          this._broadcastChange('save', key)
        }
        return fallbackResult
      }
      return false
    }
  }

  async load(key, defaultValue = null) {
    if (!key) {
      return defaultValue
    }

    await this._maybeMigrateLegacyKey(key)

    try {
      const canUseIndexedDB = await this._ensureReady()
      if (this._forceFallback || !canUseIndexedDB) {
        return this._runFallback('load', key, defaultValue)
      }
      const fullKey = this.getFullKey(key)
      const data = await indexedDBService.load(this.storeName, fullKey, defaultValue)
      return data ?? defaultValue
    } catch (error) {
      console.error(`IndexedDBPersister: Failed to load key "${key}"`, error)
      if (this._forceFallback) {
        return this._runFallback('load', key, defaultValue)
      }
      return defaultValue
    }
  }

  async remove(key) {
    if (!key) {
      return false
    }

    try {
      const canUseIndexedDB = await this._ensureReady()
      if (this._forceFallback || !canUseIndexedDB) {
        const fallbackResult = await this._runFallback('remove', key)
        if (fallbackResult) {
          this._broadcastChange('remove', key)
        }
        return fallbackResult
      }
      const fullKey = this.getFullKey(key)
      const success = await indexedDBService.delete(this.storeName, fullKey)
      if (success) {
        this._broadcastChange('remove', key)
      }
      return Boolean(success)
    } catch (error) {
      console.error(`IndexedDBPersister: Failed to remove key "${key}"`, error)
      if (this._forceFallback) {
        const fallbackResult = await this._runFallback('remove', key)
        if (fallbackResult) {
          this._broadcastChange('remove', key)
        }
        return fallbackResult
      }
      return false
    }
  }

  async clear() {
    try {
      const canUseIndexedDB = await this._ensureReady()
      if (this._forceFallback || !canUseIndexedDB) {
        const fallbackResult = await this._runFallback('clear')
        if (fallbackResult) {
          this._broadcastChange('clear')
        }
        return fallbackResult
      }
      const success = await indexedDBService.clear(this.storeName)
      if (success) {
        this._broadcastChange('clear')
      }
      return Boolean(success)
    } catch (error) {
      console.error(`IndexedDBPersister: Failed to clear store "${this.storeName}"`, error)
      if (this._forceFallback) {
        const fallbackResult = await this._runFallback('clear')
        if (fallbackResult) {
          this._broadcastChange('clear')
        }
        return fallbackResult
      }
      return false
    }
  }

  async exists(key) {
    if (!key) {
      return false
    }

    await this._maybeMigrateLegacyKey(key)

    try {
      const canUseIndexedDB = await this._ensureReady()
      if (this._forceFallback || !canUseIndexedDB) {
        return this._runFallback('exists', key)
      }
      const fullKey = this.getFullKey(key)
      const value = await indexedDBService.load(this.storeName, fullKey, null)
      return value !== null && value !== undefined
    } catch (error) {
      console.error(`IndexedDBPersister: Failed to check key "${key}"`, error)
      if (this._forceFallback) {
        return this._runFallback('exists', key)
      }
      return false
    }
  }

  async _maybeMigrateLegacyKey(key) {
    if (!key || this._forceFallback || this.fallbackStrategy === 'localstorage') {
      return
    }
    if (this.migratedLegacyKeys.has(key)) {
      return
    }
    if (typeof window === 'undefined' || !window.localStorage) {
      return
    }

    const fullKey = this.getFullKey(key)
    const legacyValue = window.localStorage.getItem(fullKey)
    if (!legacyValue) {
      this.migratedLegacyKeys.add(key)
      return
    }

    try {
      const parsed = JSON.parse(legacyValue)
      await this.save(key, parsed)
      window.localStorage.removeItem(fullKey)
      console.info('IndexedDBPersister: migrated legacy entry', { namespace: this.namespace, key })
    } catch (migrationError) {
      console.warn('IndexedDBPersister: failed to migrate legacy entry', {
        namespace: this.namespace,
        key,
        error: migrationError
      })
    } finally {
      this.migratedLegacyKeys.add(key)
    }
  }

  _broadcastChange(operation, key = null) {
    crossTabSyncService.notifyChange({
      namespace: this.namespace,
      storeName: this.storeName,
      key,
      operation
    })
  }
}
